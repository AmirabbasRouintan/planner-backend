import * as React from "react";
import {
  CalendarPlusIcon,
  DownloadIcon,
  UploadIcon,
  StickyNoteIcon
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import { Popover, PopoverTrigger, PopoverContent } from "@/components/ui/popover";
import { useAuth } from "@/contexts/AuthContext";
import {
  EventEditor,
  EventList,
  Sidebar,
  Filters,
  FullNoteEditor,
  QuickNoteDialog
} from "@/components/planner";

interface Reminder {
  time: string;
  enabled: boolean;
}
interface RecurrenceRule {
  frequency: "daily" | "weekly" | "monthly" | "yearly";
  interval: number;
  endDate?: string;
}
export interface DayEvent {
  date: string;
  description?: string;
  note?: string;
  category?: string;
  completed?: boolean;
  reminder?: Reminder;
  recurrence?: RecurrenceRule;
}

export interface PermanentNote {
  id: number;
  title: string;
  content: string;
  created_at: string;
  updated_at: string;
  timestamp?: number;
}

const STORAGE_KEY = "planner_events_v2";
const CATEGORIES = {
  work: { name: "Work", color: "#ef4444" },
  personal: { name: "Personal", color: "#3b82f6" },
  study: { name: "Study", color: "#10b981" },
  travel: { name: "Travel", color: "#f59e0b" },
  health: { name: "Health", color: "#8b5cf6" },
  other: { name: "Other", color: "#6b7280" }
} as const;

function formatKey(d: Date | string | number) {
  const date = new Date(d);
  return isNaN(date.getTime()) ? "" : date.toISOString().split("T")[0];
}

function formatReadable(d: Date | string | undefined) {
  if (!d) return "";
  const date = typeof d === "string" ? new Date(d) : d;
  if (isNaN(date.getTime())) return "";
  return date.toLocaleDateString(undefined, {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric"
  });
}

function generateRecurringEvents(
  baseEvent: DayEvent,
  endDate: Date
): DayEvent[] {
  if (!baseEvent.recurrence) return [baseEvent];
  const events: DayEvent[] = [];
  const startDate = new Date(baseEvent.date);
  const frequency = baseEvent.recurrence.frequency;
  const interval = baseEvent.recurrence.interval || 1;
  const recurrenceEndDate = baseEvent.recurrence.endDate
    ? new Date(baseEvent.recurrence.endDate)
    : endDate;
  const currentDate = new Date(startDate);
  while (currentDate <= recurrenceEndDate) {
    events.push({
      ...baseEvent,
      date: formatKey(currentDate)
    });
    switch (frequency) {
      case "daily":
        currentDate.setDate(currentDate.getDate() + interval);
        break;
      case "weekly":
        currentDate.setDate(currentDate.getDate() + 7 * interval);
        break;
      case "monthly":
        currentDate.setMonth(currentDate.getMonth() + interval);
        break;
      case "yearly":
        currentDate.setFullYear(currentDate.getFullYear() + interval);
        break;
    }
  }
  return events;
}

function checkReminders(events: Record<string, DayEvent>) {
  const now = new Date();
  Object.values(events).forEach((event) => {
    if (event.reminder && event.reminder.enabled) {
      const eventDate = new Date(event.date);
      const reminderTime = new Date(eventDate);
      switch (event.reminder.time) {
        case "30minutes":
          reminderTime.setMinutes(reminderTime.getMinutes() - 30);
          break;
        case "1hour":
          reminderTime.setHours(reminderTime.getHours() - 1);
          break;
        case "2hours":
          reminderTime.setHours(reminderTime.getHours() - 2);
          break;
        case "1day":
          reminderTime.setDate(reminderTime.getDate() - 1);
          break;
        case "2days":
          reminderTime.setDate(reminderTime.getDate() - 2);
          break;
      }
      if (now >= reminderTime && now < eventDate) {
        if (Notification.permission === "granted") {
          new Notification(`Reminder: ${event.description || "Event"}`, {
            body: `Your event is coming up on ${formatReadable(event.date)}`,
            icon: "/icon-192.png"
          });
        }
      }
    }
  });
}

function exportEventsToJSON(events: Record<string, DayEvent>) {
  const dataStr = JSON.stringify(events, null, 2);
  const dataUri = `data:application/json;charset=utf-8,${encodeURIComponent(
    dataStr
  )}`;
  const exportFileDefaultName = `planner-export-${
    new Date().toISOString().split("T")[0]
  }.json`;
  const linkElement = document.createElement("a");
  linkElement.setAttribute("href", dataUri);
  linkElement.setAttribute("download", exportFileDefaultName);
  linkElement.click();
}

function exportEventsToCSV(events: Record<string, DayEvent>) {
  const eventsArray = Object.values(events);
  let csvContent = "Date,Description,Category,Completed\n";
  eventsArray.forEach((event) => {
    csvContent += `"${event.date}","${event.description || ""}","${
      event.category || ""
    }","${event.completed ? "Yes" : "No"}"\n`;
  });
  const dataUri = `data:text/csv;charset=utf-8,${encodeURIComponent(
    csvContent
  )}`;
  const exportFileDefaultName = `planner-export-${
    new Date().toISOString().split("T")[0]
  }.csv`;
  const linkElement = document.createElement("a");
  linkElement.setAttribute("href", dataUri);
  linkElement.setAttribute("download", exportFileDefaultName);
  linkElement.click();
}

function importEventsFromFile(
  file: File,
  callback: (events: Record<string, DayEvent>) => void
) {
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const content = e.target?.result as string;
      let events: Record<string, DayEvent> = {};
      if (file.name.endsWith(".json")) {
        events = JSON.parse(content);
      } else if (file.name.endsWith(".csv")) {
        const lines = content.split("\n").map(
          (line) => line.replace(/^"(.*)"$/, "$1"),
        );
        const headers = lines[0].split(",");
        const dateIndex = headers.findIndex((h) => h.toLowerCase() === "date");
        const descriptionIndex = headers.findIndex(
          (h) => h.toLowerCase() === "description"
        );
        const categoryIndex = headers.findIndex(
          (h) => h.toLowerCase() === "category"
        );
        const completedIndex = headers.findIndex(
          (h) => h.toLowerCase() === "completed"
        );
        if (dateIndex === -1 || descriptionIndex === -1) {
          throw new Error("CSV file must contain Date and Description columns");
        }
        for (let i = 1; i < lines.length; i++) {
          if (!lines[i]) continue;
          const values = lines[i].split(",").map(
            (value) => value.replace(/^"(.*)"$/, "$1"),
          );
          if (values.length < Math.max(dateIndex, descriptionIndex) + 1) {
            continue;
          }
          const date = values[dateIndex];
          if (date && !isNaN(new Date(date).getTime())) {
            events[date] = {
              date: date,
              description: values[descriptionIndex] || "",
              category: values[categoryIndex] || "",
              completed:
                completedIndex !== -1 && values[completedIndex]
                  ? values[completedIndex].toLowerCase() === "yes" ||
                    values[completedIndex] === "1"
                  : false
            };
          }
        }
      }
      callback(events);
    } catch (error) {
      console.error("Error parsing file:", error);
      alert("Failed to import events. Please check the file format.");
    }
  };
  reader.readAsText(file);
}

export default function Planner() {
  useAuth();
  const [open, setOpen] = React.useState(false);
  const [selected, setSelected] = React.useState<Date | undefined>(new Date());
  const [events, setEvents] = React.useState<Record<string, DayEvent>>({});
  const [permanentNotes, setPermanentNotes] = React.useState<PermanentNote[]>([]);
  const [searchQuery, setSearchQuery] = React.useState("");
  const [categoryFilter, setCategoryFilter] = React.useState<string>("all");
  const [dateRangeFilter, setDateRangeFilter] = React.useState<string>("all");
  const [showCompleted, setShowCompleted] = React.useState(true);

  const [editingEvent, setEditingEvent] = React.useState<DayEvent | null>(null);
  const [editingKey, setEditingKey] = React.useState<string | null>(null);
  const [draftDescription, setDraftDescription] = React.useState("");
  const [draftCategory, setDraftCategory] = React.useState("_none_");
  const [draftReminder, setDraftReminder] = React.useState("_none_");
  const [draftRecurrence, setDraftRecurrence] = React.useState("none");
  const [draftCompleted, setDraftCompleted] = React.useState(false);

  const [noteEditorOpen, setNoteEditorOpen] = React.useState(false);
  const [fullEditorOpen, setFullEditorOpen] = React.useState<string | null>(
    null
  );
  const [fullDraft, setFullDraft] = React.useState("");
  const [markdownPreview, setMarkdownPreview] = React.useState(false);

  const [notePopupOpen, setNotePopupOpen] = React.useState(false);
  const [quickNote, setQuickNote] = React.useState("");
  const [notePreviewMode, setNotePreviewMode] = React.useState(true);

  const minDate = React.useMemo(() => {
    const date = new Date();
    date.setFullYear(date.getFullYear() - 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }, []);

  const maxDate = React.useMemo(() => {
    const date = new Date();
    date.setFullYear(date.getFullYear() + 5);
    date.setHours(0, 0, 0, 0);
    return date;
  }, []);

  const clampDate = React.useCallback(
    (date: Date) => {
      return new Date(
        Math.min(Math.max(date.getTime(), minDate.getTime()), maxDate.getTime())
      );
    },
    [minDate, maxDate]
  );

  const isDateDisabled = React.useCallback(
    (date: Date) => date < minDate || date > maxDate,
    [minDate, maxDate]
  );

  const handleDateSelect = React.useCallback(
    (d: Date | undefined) => {
      if (!d || isNaN(d.getTime())) return;
      const clampedDate = clampDate(d);
      setSelected(clampedDate);
    },
    [clampDate]
  );

  React.useEffect(() => {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (raw) {
        const parsed = JSON.parse(raw) as Record<string, DayEvent>;
        setEvents(parsed || {});
      }

      const initialDate = new Date();
      setSelected(clampDate(new Date()));
    } catch (e) {
      console.warn("Failed to load planner events", e);
      setSelected(clampDate(new Date()));
    }
  }, [clampDate]);

  React.useEffect(() => {
    try {
      const savedNotes = localStorage.getItem('permanent-notes');
      if (savedNotes) {
        const notes = JSON.parse(savedNotes);
        setPermanentNotes(notes);
      }
    } catch (error) {
      console.error('Error loading notes from localStorage:', error);
    }
  }, []);

  React.useEffect(() => {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(events));
    } catch (e) {
      console.warn("Failed to save planner events", e);
    }
  }, [events]);

  React.useEffect(() => {
    if ("Notification" in window && Notification.permission === "default") {
      Notification.requestPermission();
    }
    const interval = setInterval(() => {
      checkReminders(events);
    }, 60000);
    checkReminders(events);
    return () => clearInterval(interval);
  }, [events]);

  const currentDate = React.useMemo(
    () => selected || clampDate(new Date()),
    [selected, clampDate]
  );
  const currentYear = React.useMemo(
    () => currentDate.getFullYear(),
    [currentDate]
  );
  const currentMonth = React.useMemo(
    () => currentDate.toLocaleString("default", { month: "long" }),
    [currentDate]
  );
  const daysInMonth = React.useMemo(
    () =>
      new Date(
        currentDate.getFullYear(),
        currentDate.getMonth() + 1,
        0
      ).getDate(),
    [currentDate]
  );
  const daysArray = React.useMemo(
    () =>
      Array.from(
        { length: daysInMonth },
        (_, i) =>
          new Date(currentDate.getFullYear(), currentDate.getMonth(), i + 1)
      ),
    [currentDate, daysInMonth]
  );

  const filteredEvents = React.useMemo(() => {
    let filtered = { ...events };
    if (searchQuery) {
      filtered = Object.fromEntries(
        Object.entries(events).filter(
          ([, event]) =>
            (event.description || "")
              .toLowerCase()
              .includes(searchQuery.toLowerCase()) ||
            (event.note || "").toLowerCase().includes(searchQuery.toLowerCase())
        )
      );
    }
    if (categoryFilter !== "all") {
      filtered = Object.fromEntries(
        Object.entries(filtered).filter(
          ([, event]) => event.category === categoryFilter
        )
      );
    }
    if (!showCompleted) {
      filtered = Object.fromEntries(
        Object.entries(filtered).filter(([, event]) => !event.completed)
      );
    }
    if (dateRangeFilter !== "all") {
      const today = new Date();
      const startDate = new Date(today);
      const endDate = new Date(today);
      switch (dateRangeFilter) {
        case "today":
          break;
        case "week":
          endDate.setDate(today.getDate() + 7);
          break;
        case "month":
          endDate.setMonth(today.getMonth() + 1);
          break;
        case "next7days":
          endDate.setDate(today.getDate() + 7);
          break;
        case "next30days":
          endDate.setDate(today.getDate() + 30);
          break;
      }
      if (dateRangeFilter !== "today") {
        filtered = Object.fromEntries(
          Object.entries(filtered).filter(([, event]) => {
            const eventDate = new Date(event.date);
            return eventDate >= startDate && eventDate <= endDate;
          })
        );
      } else {
        const todayKey = formatKey(today);
        filtered = Object.fromEntries(
          Object.entries(filtered).filter(([key]) => key === todayKey)
        );
      }
    }
    return filtered;
  }, [events, searchQuery, categoryFilter, dateRangeFilter, showCompleted]);

  const eventsWithRecurrence = React.useMemo(() => {
    const allEvents = { ...events };
    const endDate = new Date();
    endDate.setFullYear(endDate.getFullYear() + 1);
    Object.values(events).forEach((event) => {
      if (event.recurrence) {
        const recurringEvents = generateRecurringEvents(event, endDate);
        recurringEvents.forEach((recurringEvent) => {
          if (
            !allEvents[recurringEvent.date] ||
            recurringEvent.date === event.date
          ) {
            allEvents[recurringEvent.date] = recurringEvent;
          }
        });
      }
    });
    return allEvents;
  }, [events]);

  const viewEvents = React.useMemo(() => {
    return dateRangeFilter === "all" ? eventsWithRecurrence : filteredEvents;
  }, [dateRangeFilter, eventsWithRecurrence, filteredEvents]);

  const currentEvents = React.useMemo(() => {
    return viewEvents;
  }, [viewEvents]);

  const saveDescription = React.useCallback(() => {
    if (!selected && !editingKey) return;
    const key = editingKey || (selected ? formatKey(selected) : null);
    if (!key) return;

    const eventData: DayEvent = {
      date: key,
      description: draftDescription,
      category: draftCategory !== "_none_" ? draftCategory : undefined,
      completed: draftCompleted,
      note: events[key]?.note
    };

    if (draftReminder !== "_none_") {
      eventData.reminder = {
        time: draftReminder,
        enabled: true
      };
    }

    if (draftRecurrence !== "none") {
      eventData.recurrence = {
        frequency: draftRecurrence as "daily" | "weekly" | "monthly" | "yearly",
        interval: 1
      };
    }

    setEvents((prev) => ({
      ...prev,
      [key]: eventData
    }));

    setOpen(false);
    setEditingKey(null);
    setDraftDescription("");
    setDraftCategory("_none_");
    setDraftReminder("_none_");
    setDraftRecurrence("none");
    setDraftCompleted(false);
  }, [
    selected,
    editingKey,
    draftDescription,
    draftCategory,
    draftReminder,
    draftRecurrence,
    draftCompleted,
    events
  ]);

  const saveFullNote = React.useCallback(
    (key?: string) => {
      const k = key || fullEditorOpen;
      if (!k) return;
      setEvents((prev) => ({
        ...prev,
        [k]: {
          ...(prev[k] || {}),
          date: k,
          note: fullDraft
        }
      }));
      setFullEditorOpen(null);
      setFullDraft("");
      setMarkdownPreview(false);
    },
    [fullEditorOpen, fullDraft]
  );

  const handleSaveNote = React.useCallback(async () => {
    if (!quickNote.trim()) return;
    
    saveNoteLocally();
    
    setQuickNote("");
    setNotePopupOpen(false);
  }, [quickNote]);

  const saveNoteLocally = React.useCallback(() => {
    const noteKey = `note_${Date.now()}`;
    const noteDate = formatKey(new Date());
    
    setEvents((prev) => ({
      ...prev,
      [noteKey]: {
        date: noteDate,
        description: quickNote.trim(),
        category: "note",
        note: quickNote.trim()
      }
    }));
    
    try {
      const newNote = {
        id: noteKey,
        title: 'Permanent Note',
        content: quickNote.trim(),
        date: noteDate,
        timestamp: Date.now()
      };
      
      const existingNotes = JSON.parse(localStorage.getItem('permanent-notes') || '[]');
      const updatedNotes = [newNote, ...existingNotes];
      localStorage.setItem('permanent-notes', JSON.stringify(updatedNotes));
      
      setPermanentNotes(updatedNotes);
    } catch (error) {
      console.error('Error saving note to localStorage:', error);
    }
  }, [quickNote]);

  const applyFormatting = React.useCallback((prefix: string, suffix: string) => {
    const textarea = document.getElementById('quick-note') as HTMLTextAreaElement;
    if (!textarea) return;

    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const selectedText = quickNote.substring(start, end);
    let cursorPos = textarea.selectionStart;

    if (selectedText) {
      const newText = quickNote.substring(0, start) + prefix + selectedText + suffix + quickNote.substring(end);
      setQuickNote(newText);
    } else {
      cursorPos = textarea.selectionStart;
      const textBefore = quickNote.substring(0, cursorPos);
      const textAfter = quickNote.substring(cursorPos);
      setQuickNote(textBefore + prefix + suffix + textAfter);
    }
    
    textarea.focus();
    setTimeout(() => {
      textarea.focus();
      if (selectedText) {
        textarea.setSelectionRange(start, end + prefix.length + suffix.length);
      } else {
        textarea.setSelectionRange(cursorPos + prefix.length, cursorPos + prefix.length);
      }
    }, 0);
  }, [quickNote]);

  const deleteEvent = React.useCallback(
    (key: string) => {
      setEvents((prev) => {
        const copy = { ...prev };
        delete copy[key];
        return copy;
      });
      if (editingKey === key) {
        setEditingKey(null);
        setDraftDescription("");
        setOpen(false);
      }
      if (fullEditorOpen === key) {
        setFullEditorOpen(null);
        setFullDraft("");
      }
    },
    [editingKey, fullEditorOpen]
  );

  const cancelDescriptionEdit = React.useCallback(() => {
    setEditingKey(null);
    setDraftDescription("");
    setDraftCategory("_none_");
    setDraftReminder("_none_");
    setDraftRecurrence("none");
    setDraftCompleted(false);
    setOpen(false);
  }, []);

  const cancelFull = React.useCallback(() => {
    setFullEditorOpen(null);
    setFullDraft("");
    setMarkdownPreview(false);
  }, []);

  const eventCount = React.useMemo(
    () => Object.keys(viewEvents).length,
    [viewEvents]
  );

  const handleTodayClick = React.useCallback(() => {
    const today = new Date();
    const clampedToday = clampDate(today);
    setSelected(clampedToday);
    const todayKey = formatKey(clampedToday);
    const todayEvent = events[todayKey];

    setDraftDescription(todayEvent?.description || "");
    setDraftCategory(todayEvent?.category || "_none_");
    setDraftReminder(todayEvent?.reminder?.time || "_none_");
    setDraftRecurrence(todayEvent?.recurrence?.frequency || "none");
    setDraftCompleted(todayEvent?.completed || false);

    setEditingKey(todayKey);
    setOpen(true);
  }, [events, clampDate]);

  const saveFromSideEditor = React.useCallback(() => {
    if (!selected) return;
    const key = formatKey(selected);

    const eventData: DayEvent = {
      date: key,
      description: draftDescription,
      category: draftCategory !== "_none_" ? draftCategory : undefined,
      completed: draftCompleted,
      note: events[key]?.note
    };

    if (draftReminder !== "_none_") {
      eventData.reminder = {
        time: draftReminder,
        enabled: true
      };
    }

    setEvents((prev) => ({
      ...prev,
      [key]: eventData
    }));
  }, [
    selected,
    draftDescription,
    draftCategory,
    draftReminder,
    draftCompleted,
    events
  ]);

  const toggleCompletion = React.useCallback((key: string) => {
    setEvents((prev) => ({
      ...prev,
      [key]: {
        ...prev[key],
        completed: !prev[key]?.completed
      }
    }));
  }, []);

  const handleFileImport = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      importEventsFromFile(file, (importedEvents) => {
        if (
          window.confirm(
            "Import events? This will merge with your existing events."
          )
        ) {
          setEvents((prev) => ({ ...prev, ...importedEvents }));
        }
      });
    }
  };

  return (
    <div className="flex flex-col items-center min-h-screen w-full p-3 sm:p-4 gap-3 sm:gap-4 pb-20 md:pb-16">
      <div className="w-full max-w-7xl">
        <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3 sm:gap-4">
          <div>
            <h1 className="text-xl sm:text-2xl font-semibold">Planner</h1>
            <p className="text-xs sm:text-sm text-muted-foreground">
              Quickly add and manage events :3
            </p>
          </div>
          <div className="flex items-center gap-1 sm:gap-2 flex-wrap">
            <Label htmlFor="date" className="sr-only">
              Select date
            </Label>
            <EventEditor
              open={open}
              onOpenChange={setOpen}
              selectedDate={selected}
              handleDateSelect={handleDateSelect}
              isDateDisabled={isDateDisabled}
              draftDescription={draftDescription}
              setDraftDescription={setDraftDescription}
              draftCategory={draftCategory}
              setDraftCategory={setDraftCategory}
              draftReminder={draftReminder}
              setDraftReminder={setDraftReminder}
              draftRecurrence={draftRecurrence}
              setDraftRecurrence={setDraftRecurrence}
              draftCompleted={draftCompleted}
              setDraftCompleted={setDraftCompleted}
              saveDescription={saveDescription}
              cancelDescriptionEdit={cancelDescriptionEdit}
              editingKey={editingKey}
            />
            <Button variant="outline" onClick={handleTodayClick}>
              Today
            </Button>
            {/* Export buttons */}
            <Popover>
              <PopoverTrigger asChild>
                <Button variant="outline" size="icon">
                  <DownloadIcon className="h-4 w-4" />
                </Button>
              </PopoverTrigger>
              <PopoverContent className="w-48 p-2">
                <div className="space-y-2">
                  <Button
                    variant="ghost"
                    className="w-full justify-start"
                    onClick={() => exportEventsToJSON(events)}
                  >
                    Export as JSON
                  </Button>
                  <Button
                    variant="ghost"
                    className="w-full justify-start"
                    onClick={() => exportEventsToCSV(events)}
                  >
                    Export as CSV
                  </Button>
                </div>
              </PopoverContent>
            </Popover>
            {/* Import button */}
            <Button variant="outline" size="icon" asChild>
              <Label htmlFor="import-file" className="cursor-pointer">
                <UploadIcon className="h-4 w-4" />
                <input
                  id="import-file"
                  type="file"
                  accept=".json,.csv"
                  onChange={handleFileImport}
                  className="hidden"
                />
              </Label>
            </Button>
            {/* Note button */}
            <Button
              variant="outline"
              size="icon"
              onClick={() => setNotePopupOpen(true)}
              title="Add Note"
            >
              <StickyNoteIcon className="h-4 w-4" />
            </Button>
          </div>
        </div>
        {/* Search and filter bar */}
        <Filters
          searchQuery={searchQuery}
          setSearchQuery={setSearchQuery}
          categoryFilter={categoryFilter}
          setCategoryFilter={setCategoryFilter}
          dateRangeFilter={dateRangeFilter}
          setDateRangeFilter={setDateRangeFilter}
          showCompleted={showCompleted}
          setShowCompleted={setShowCompleted}
          CATEGORIES={CATEGORIES}
        />
        <div className="mt-4 sm:mt-6 grid grid-cols-1 lg:grid-cols-3 gap-3 sm:gap-4">
          <aside className="lg:col-span-2 border rounded-lg p-2 sm:p-3 h-[50vh] sm:h-[calc(100vh-16rem)] bg-[var(--calendar-date-bg)]">
            <EventList
              daysArray={daysArray}
              viewEvents={viewEvents}
              selectedDate={selected}
              handleDateSelect={handleDateSelect}
              toggleCompletion={toggleCompletion}
              setEditingKey={setEditingKey}
              onOpenChange={setOpen}
              setDraftDescription={setDraftDescription}
              setDraftCategory={setDraftCategory}
              setDraftReminder={setDraftReminder}
              setDraftRecurrence={setDraftRecurrence}
              setDraftCompleted={setDraftCompleted}
              setFullDraft={setFullDraft}
              setFullEditorOpen={setFullEditorOpen}
              deleteEvent={deleteEvent}
              formatKey={formatKey}
              eventCount={eventCount}
              currentMonth={currentMonth}
              currentYear={currentYear}
            />
          </aside>
          <section className="md:col-span-1 border rounded-lg p-3 bg-[var(--calendar-date-bg)]">
            <Sidebar
              selectedDate={selected}
              events={events}
              formatKey={formatKey}
              draftDescription={draftDescription}
              setDraftDescription={setDraftDescription}
              setDraftCategory={setDraftCategory}
              setDraftReminder={setDraftReminder}
              setDraftRecurrence={setDraftRecurrence}
              setDraftCompleted={setDraftCompleted}
              saveFromSideEditor={saveFromSideEditor}
              permanentNotes={permanentNotes}
              setQuickNote={setQuickNote}
              setNotePreviewMode={setNotePreviewMode}
              setNotePopupOpen={setNotePopupOpen}
            />
          </section>
        </div>
        <FullNoteEditor
          fullEditorOpen={fullEditorOpen}
          setFullEditorOpen={setFullEditorOpen}
          fullDraft={fullDraft}
          setFullDraft={setFullDraft}
          saveFullNote={saveFullNote}
          markdownPreview={markdownPreview}
          setMarkdownPreview={setMarkdownPreview}
          formatReadable={formatReadable}
          cancelFull={cancelFull}
        />
        
        <QuickNoteDialog
          notePopupOpen={notePopupOpen}
          setNotePopupOpen={setNotePopupOpen}
          quickNote={quickNote}
          setQuickNote={setQuickNote}
          handleSaveNote={handleSaveNote}
          notePreviewMode={notePreviewMode}
          setNotePreviewMode={setNotePreviewMode}
          applyFormatting={applyFormatting}
        />
      </div>
    </div>
  );
}

}

                                  size="sm"
                                  className="h-8 w-8 p-0 touch-manipulation min-h-[32px] min-w-[32px]"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    toggleCompletion(key);
                                  }}
                                  aria-label={
                                    evt.completed
                                      ? "Mark as not completed"
                                      : "Mark as completed"
                                  }
                                >
                                  <CheckCircleIcon
                                    className={`h-4 w-4 ${
                                      evt.completed
                                        ? "text-green-500"
                                        : "text-muted-foreground"
                                    }`}
                                  />
                                </Button>
                              </TooltipTrigger>
                              <TooltipContent>
                                <p>
                                  {evt.completed
                                    ? "Completed"
                                    : "Mark as completed"}
                                </p>
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        )}
                        <TooltipProvider>
                          <Tooltip>
                            <TooltipTrigger asChild>
                              <Button
                                variant="ghost"
                                size="sm"
                                className="h-8 w-8 p-0 touch-manipulation min-h-[32px] min-w-[32px]"
                                onClick={(e) => {
                                  e.stopPropagation();
                                  const dayToSelect = new Date(day); 
                                  setSelected(dayToSelect);
                                  setDraftDescription(evt?.description || "");
                                  setDraftCategory(evt?.category || "_none_");
                                  setDraftReminder(evt?.reminder?.time || "_none_");
                                  setDraftRecurrence(
                                    evt?.recurrence?.frequency || "none"
                                  );
                                  setDraftCompleted(evt?.completed || false);
                                  setEditingKey(key);
                                  setOpen(true);
                                }}
                                aria-label={`Edit event on ${key}`}
                              >
                                <Edit3Icon className="h-4 w-4" />
                              </Button>
                            </TooltipTrigger>
                            <TooltipContent>
                              <p>Edit</p>
                            </TooltipContent>
                          </Tooltip>
                        </TooltipProvider>
                        <TooltipProvider>
                          <Tooltip>
                            <TooltipTrigger asChild>
                              <Button
                                variant="ghost"
                                size="sm"
                                className="h-8 w-8 p-0 touch-manipulation min-h-[32px] min-w-[32px]"
                                onClick={(e) => {
                                  e.stopPropagation();
                                  handleDateSelect(day);
                                  setFullDraft(evt?.note || "");
                                  setFullEditorOpen(key);
                                }}
                                aria-label={`Open full note for ${key}`}
                              >
                                <FileTextIcon className="h-4 w-4" />
                              </Button>
                            </TooltipTrigger>
                            <TooltipContent>
                              <p>Open fullâ€‘screen note</p>
                            </TooltipContent>
                          </Tooltip>
                        </TooltipProvider>
                        {evt && (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <Button
                                  variant="ghost"
                                  size="sm"
                                  className="h-8 w-8 p-0 touch-manipulation min-h-[32px] min-w-[32px]"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    if (confirm(`Delete event on ${key}?`))
                                      deleteEvent(key);
                                  }}
                                  aria-label={`Delete event on ${key}`}
                                >
                                  <Trash2Icon className="h-4 w-4" />
                                </Button>
                              </TooltipTrigger>
                              <TooltipContent>
                                <p>Delete</p>
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        )}
                      </div>
                    </div>
                  );
                })}
              </div>
            </ScrollArea>
          </aside>
          <section className="md:col-span-1 border rounded-lg p-3 bg-[var(--calendar-date-bg)]">
            <ScrollArea
              className="pr-4 pl-2 h-auto min-h-fit"
              style={{ scrollbarGutter: "stable" }}
            >
              <div className="flex items-center justify-between mb-3">
                <div>
                  <h3 className="text-sm font-medium">Selected</h3>
                  <div className="text-xs text-muted-foreground">
                    {selected ? selected.toLocaleDateString() : "â€”"}
                  </div>
                </div>
                <div>
                  {selected && events[formatKey(selected)] ? (
                    <Badge>Saved</Badge>
                  ) : (
                    <Badge variant="outline">Empty</Badge>
                  )}
                </div>
              </div>
              <div className="mt-2">
                <Label htmlFor="side-desc">Description</Label>
                <Textarea
                  className="mt-2"
                  id="side-desc"
                  placeholder="Type a short description and press Save"
                  value={draftDescription}
                  onChange={(e) => setDraftDescription(e.target.value)}
                  rows={4}
                />
                <div className="flex justify-end gap-2 mt-3">
                  <Button
                    variant="outline"
                    onClick={() => {
                      setDraftDescription("");
                      setDraftCategory("_none_");
                      setDraftReminder("_none_");
                      setDraftRecurrence("none");
                      setDraftCompleted(false);
                    }}
                  >
                    Reset
                  </Button>
                  <Button
                    onClick={saveFromSideEditor}
                    disabled={!selected || !draftDescription.trim()}
                  >
                    Save
                  </Button>
                </div>
                <div className="mt-4">
                  <Label>Full note</Label>
                  <div className="mt-2 text-sm text-muted-foreground">
                    {selected && events[formatKey(selected)]?.note
                      ? events[formatKey(selected)]!.note
                      : "No full note. Use the note button beside Edit to open the fullâ€‘screen notepad."}
                  </div>
                </div>
              </div>
              <div className="mt-6 text-sm text-muted-foreground">
                Tips: Description and full notes are stored separately. Press{" "}
                <kbd className="rounded border px-1">Ctrl</kbd> +{" "}
                <kbd className="rounded border px-1">Enter</kbd> to save in
                editors.
              </div>
              
              {/* Permanent Notes Section */}
              {permanentNotes.length > 0 && (
                <div className="mt-4 sm:mt-6">
                  <div className="flex items-center justify-between mb-2 sm:mb-3">
                    <h3 className="text-sm font-medium">Permanent Notes</h3>
                    <Badge variant="secondary" className="text-xs">{permanentNotes.length}</Badge>
                  </div>
                  <div className="space-y-1 sm:space-y-2">
                    {permanentNotes.slice(0, 3).map((note) => (
                      <div 
                        key={note.id} 
                        className="p-2 border rounded text-sm cursor-pointer hover:bg-muted transition-colors touch-manipulation"
                        onClick={() => {
                          setQuickNote(note.content);
                          setNotePreviewMode(true);
                          setNotePopupOpen(true);
                        }}
                      >
                        <div className="line-clamp-2 text-xs sm:text-sm">{note.content}</div>
                        <div className="text-xs text-muted-foreground mt-1">
                          {note.timestamp ? new Date(note.timestamp).toLocaleDateString() : 'Unknown date'}
                        </div>
                      </div>
                    ))}
                    {permanentNotes.length > 3 && (
                      <div className="text-xs text-muted-foreground text-center pt-1">
                        +{permanentNotes.length - 3} more notes
                      </div>
                    )}
                  </div>
                </div>
              )}
              
            </ScrollArea>
          </section>
        </div>
        {fullEditorOpen && (
          <div className="fixed inset-0 z-50 flex flex-col bg-background">
            <div className="flex flex-col sm:flex-row sm:items-center justify-between p-3 sm:p-4 border-b shadow-sm gap-3">
              <div>
                <div className="text-xs sm:text-sm text-muted-foreground">
                  Editing note
                </div>
                <div className="text-base sm:text-lg font-semibold">
                  {formatReadable(fullEditorOpen)}
                </div>
              </div>
              <div className="flex items-center gap-2 flex-wrap">
                <Button
                  variant="outline"
                  onClick={() => setMarkdownPreview(!markdownPreview)}
                  className="text-xs sm:text-sm px-2 py-1 h-7 sm:h-9"
                >
                  {markdownPreview ? "Edit" : "Preview"}
                </Button>
                <Button
                  variant="outline"
                  onClick={cancelFull}
                  aria-label="Cancel full editor"
                  className="text-xs sm:text-sm px-2 py-1 h-7 sm:h-9"
                >
                  <XIcon className="h-3 w-3 sm:h-4 sm:w-4" />
                  Cancel
                </Button>
                <Button
                  onClick={() => saveFullNote()}
                  disabled={!fullDraft.trim()}
                  className="text-xs sm:text-sm px-2 py-1 h-7 sm:h-9"
                >
                  <SaveIcon className="h-3 w-3 sm:h-4 sm:w-4" />
                  Save
                </Button>
              </div>
            </div>
            <ResizablePanelGroup direction="horizontal" className="flex-1">
              <ResizablePanel defaultSize={70} minSize={30}>
                <div className="p-3 sm:p-4 h-full">
                  {markdownPreview ? (
                    <div className="prose prose-xs sm:prose-sm dark:prose-invert max-w-none p-3 sm:p-4 border rounded-md h-full overflow-auto">
                      {fullDraft || <em>No content to preview</em>}
                    </div>
                  ) : (
                    <Textarea
                      value={fullDraft}
                      onChange={(e) => setFullDraft(e.target.value)}
                      className="h-full min-h-[40vh] sm:min-h-[30vh] w-full resize-none font-mono text-sm"
                      placeholder={`Write anything you want for ${formatReadable(
                        fullEditorOpen
                      )}... (Markdown supported)`}
                      onKeyDown={(e) => {
                        if (e.key === "Enter" && (e.ctrlKey || e.metaKey))
                          saveFullNote();
                        if (e.key === "Escape") cancelFull();
                      }}
                    />
                  )}
                </div>
              </ResizablePanel>
              {!markdownPreview && (
                <>
                  <ResizableHandle />
                  <ResizablePanel defaultSize={30} minSize={20}>
                    <div className="p-3 sm:p-4 h-full overflow-auto">
                      <div className="prose prose-xs sm:prose-sm dark:prose-invert max-w-none">
                        <h3 className="text-base sm:text-lg">Markdown Preview</h3>
                        <div className="border rounded-md p-3 sm:p-4">
                          {fullDraft || <em>No content to preview</em>}
                        </div>
                        <div className="mt-3 sm:mt-4 text-xs sm:text-sm text-muted-foreground">
                          <h4 className="text-sm sm:text-base">Markdown Tips:</h4>
                          <ul className="space-y-1">
                            <li>
                              **Bold** for <strong>bold text</strong>
                            </li>
                            <li>
                              *Italic* for <em>italic text</em>
                            </li>
                            <li># Heading 1</li>
                            <li>## Heading 2</li>
                            <li>- List items</li>
                            <li>[Link](https://example.com)</li>
                          </ul>
                        </div>
                      </div>
                    </div>
                  </ResizablePanel>
                </>
              )}
            </ResizablePanelGroup>
          </div>
        )}
        
        <Dialog open={notePopupOpen} onOpenChange={setNotePopupOpen}>
          <DialogContent className="max-w-2xl max-h-[85vh] mx-2 sm:mx-0">
            <DialogHeader>
              <div className="flex items-center gap-2">
                <DialogTitle className="flex items-center gap-2 text-base sm:text-lg">
                  <span>Keep Note Forever</span>
                  <div className="flex items-center gap-1 text-yellow-500">
                    <svg className="w-4 h-4 sm:w-5 sm:h-5" fill="currentColor" viewBox="0 0 20 20">
                      <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
                    </svg>
                    <span className="text-xs sm:text-sm font-normal">Keep your note here always</span>
                  </div>
                </DialogTitle>
              </div>
              <DialogDescription>
                
              </DialogDescription>
            </DialogHeader>
            <div className="grid gap-3 sm:gap-4 py-3 sm:py-4">
              <div className="flex flex-col sm:flex-row sm:items-center justify-between gap-3 mb-2">
                <div className="flex gap-1 sm:gap-2 flex-wrap">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => applyFormatting('# ', '')}
                    className="text-xs px-2 py-1 h-7 sm:h-8"
                  >
                    H1
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => applyFormatting('**', '**')}
                    className="text-xs font-bold px-2 py-1 h-7 sm:h-8"
                  >
                    B
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => applyFormatting('*', '*')}
                    className="text-xs underline px-2 py-1 h-7 sm:h-8"
                  >
                    I
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => applyFormatting('~~', '~~')}
                    className="text-xs line-through px-2 py-1 h-7 sm:h-8"
                  >
                    S
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => applyFormatting('\n- [ ] ', '')}
                    className="text-xs px-2 py-1 h-7 sm:h-8"
                  >
                    ☑
                  </Button>
                </div>
                <div className="flex items-center gap-2">
                  <Label htmlFor="note-preview-toggle" className="text-xs sm:text-sm">
                    {notePreviewMode ? "Preview" : "Edit"}
                  </Label>
                  <button
                    id="note-preview-toggle"
                    role="switch"
                    aria-checked={notePreviewMode}
                    onClick={() => setNotePreviewMode(!notePreviewMode)}
                    className={`relative inline-flex h-5 w-9 sm:h-6 sm:w-11 items-center rounded-full transition-colors ${
                      notePreviewMode ? "bg-primary" : "bg-input"
                    }`}
                  >
                    <span
                      className={`inline-block h-3 w-3 sm:h-4 sm:w-4 transform rounded-full bg-background transition-transform ${
                        notePreviewMode ? "translate-x-5 sm:translate-x-6" : "translate-x-1"
                      }`}
                    />
                  </button>
                </div>
              </div>
              
              {!notePreviewMode ? (
                <div className="grid gap-3 sm:gap-4">
                  <div className="grid gap-2">
                    <Label htmlFor="quick-note" className="text-sm sm:text-base">Note Content</Label>
                    <Textarea
                      id="quick-note"
                      value={quickNote}
                      onChange={(e) => setQuickNote(e.target.value)}
                      placeholder="Write your permanent note here..."
                      rows={5}
                      className="resize-none text-sm font-light"
                    />
                  </div>
                  
                  {quickNote && (
                    <div className="grid gap-2">
                      <Label className="text-sm sm:text-base">Preview</Label>
                      <div className="border rounded-md p-2 sm:p-3 bg-muted/30 min-h-[80px] sm:min-h-[100px] max-h-[150px] sm:max-h-[200px] overflow-y-auto">
                        <div className="prose prose-xs sm:prose-sm dark:prose-invert max-w-none">
                          <div dangerouslySetInnerHTML={{
                            __html: quickNote
                              .replace(/^# (.*$)/gim, '<h1 style="font-size: 1.5em; font-weight: bold; margin: 0.5em 0;">$1</h1>')
                              .replace(/^## (.*$)/gim, '<h2 style="font-size: 1.3em; font-weight: bold; margin: 0.6em 0;">$1</h2>')
                              .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                              .replace(/\*(.*?)\*/g, '<em>$1</em>')
                              .replace(/~~(.*?)~~/g, '<del>$1</del>')
                              .replace(/^- \[ \] (.*$)/gim, '<div><input type="checkbox" class="mr-2" disabled> $1</div>')
                              .replace(/^- \[x\] (.*$)/gim, '<div><input type="checkbox" class="mr-2" checked disabled> $1</div>')
                              .replace(/\n/g, '<br>')
                          }} />
                        </div>
                      </div>
                    </div>
                  )}
                </div>
              ) : (
                <div className="grid gap-2">
                  <Label className="text-sm sm:text-base">Preview</Label>
                  <div className="border rounded-md p-2 sm:p-3 bg-muted/30 min-h-[200px] sm:min-h-[300px] max-h-[300px] sm:max-h-[400px] overflow-y-auto">
                    <div className="prose prose-xs sm:prose-sm dark:prose-invert max-w-none">
                      {quickNote ? (
                        <div dangerouslySetInnerHTML={{
                          __html: quickNote
                            .replace(/^# (.*$)/gim, '<h1 style="font-size: 1.5em; font-weight: bold; margin: 0.5em 0;">$1</h1>')
                            .replace(/^## (.*$)/gim, '<h2 style="font-size: 1.3em; font-weight: bold; margin: 0.6em 0;">$1</h2>')
                            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                            .replace(/\*(.*?)\*/g, '<em>$1</em>')
                            .replace(/~~(.*?)~~/g, '<del>$1</del>')
                            .replace(/^- \[ \] (.*$)/gim, '<div><input type="checkbox" class="mr-2" disabled> $1</div>')
                            .replace(/^- \[x\] (.*$)/gim, '<div><input type="checkbox" class="mr-2" checked disabled> $1</div>')
                            .replace(/\n/g, '<br>')
                        }} />
                      ) : (
                        <em>No content to preview</em>
                      )}
                    </div>
                  </div>
                </div>
              )}
            </div>
            <DialogFooter className="gap-2">
              <Button variant="outline" onClick={() => {
                setQuickNote("");
                setNotePopupOpen(false);
              }} className="text-sm sm:text-base">
                Cancel
              </Button>
              <Button onClick={handleSaveNote} disabled={!quickNote.trim()} className="text-sm sm:text-base">
                Save Permanent Note
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
        
      </div>
    </div>
  );
}
